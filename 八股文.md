### mysql

####  mysql引擎

mysql常见存储引擎，InnoDb,MyISAM,MEMORY。区别在事务支持，外键支持，存储限制，空间使用，插入速度的区别。

| 特性     | InnoDb | MyISAM         | MEMORY         |
| -------- | ------ | -------------- | -------------- |
| 事务支持 | 支持   | 不支持         | 不支持         |
| 外键     | 支持   | 不支持         | 不支持         |
| 存储限制 | 64TB   | 有，视情况而定 | 有，视情况而定 |
| 空间使用 | 高     | 低             | 低             |
| 内存使用 | 高     | 低             | 高             |
| 插入速度 | 低     | 高             | 高             |

mysql 5.5.5之前是默认引擎是MyISAM。

MyISAM特点：插入速度快，空间和内存使用较低。主要用于插入新纪录和读取数据。

MEMORY特点：所有数据都在内存中，数据的处理速度特别快，但是安全性不高，不能建立太大的表。

### mysql事务

一般来说，事务必须满足四个条件：原子性，一致性，隔离性，持久性

#### 原子性

一个事务中的所有操作，要么全部完成，要么全部不完成。不会结束在中间某个环节，事务在执行过程中发生错误，会被回滚至事务最开始的状态，就好像这个事务没有发生过一样。

#### 一致性

在事务的开始之前和结束之后，数据库的完整性没有被破坏。

#### 隔离性

数据库允许多个事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据库不一致。事务有不同的隔离级别：**读未提交**，**读已提交**，**可重复读**和**串行化**。mysql innodb默认隔离级别为**可重复读**。

##### 事务并发问题

- 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据。

- 不可重复读：事务A多次读取同一事务，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致。

- 幻读：系统管理员A将数据库中的学生成绩从具体分数改为ABCDE等级，但是这时系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。

  **注**：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。

#### 持久性

事务处理结束后，对数据的修改是永久的。

| 隔离级别 | **脏读** | **不可重复读** | **幻读** |
| -------- | -------- | -------------- | -------- |
| 读未提交 | 可能     | 可能           | 可能     |
| 读已提交 | 不可能   | 可能           | 可能     |
| 可重复读 | 不可能   | 不可能         | 可能     |
| 可串行化 | 不可能   | 不可能         | 不可能   |

#### mysql sql语句优化



### redis

#### 数据结构

1、string：单key，单vale。redis最基本的数据类型，一个redis字符最大支持512m

2、hash：一个键值集合

3、list：链表

4、set：集合

5、zset：有序集合

#### 常用指令

| 命令                    | 操作                                                       |
| ----------------------- | ---------------------------------------------------------- |
| keys pattern            | 以正则表达式的形式，返回匹配所有key                        |
| exists key              | 测试指定key是否存在                                        |
| type key                | 返回给定key的类型                                          |
| ttl key                 | 查看key的剩余时间                                          |
| set key value           | 设置key对应值为string的value                               |
| lpush key value1        | 在key对应的list头部（左端）添加元素                        |
| lpop key                | 移除并返回key对应的list的头部（左端）元素                  |
| sadd key value1         | 将元素添加至集合，并返回添加成功个数                       |
| srem key value1         | 从集合移除元素，返回移除成功的个数                         |
| zadd key score1 member1 | 将带有分值的成员添加到有序集合中。注意分值在前，成员在后。 |
| zrem key                | 从有序集合中删除指定成员，并返回成功删除的元素个数         |
| hset key field value    | 向散列key添加一个键值对                                    |
| hget key field          | 向散列key获取一个键的key                                   |
| hdel key field1         | 删除散列一个键值对，返回成功删除键值对的数量               |

#### 持久化

1、redis提供了两种持久化方式，分别是RDB（redis database）和AOF（Append Only File）

2、RDB（默认）：在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上。

3、AOF：将redis执行过的所有指令记录下来，下次redis重新启动时，只要这些指令重复执行一遍，就可以实现数据恢复了。

4、RDB和AOF两种方式可以同时使用。redis重启时会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。

5、如果没有数据持久化需求，也可以关闭RDB和AOF方式，这样redis将变成一个纯内存数据库。

#### redis集群三种模式

##### 主从复制模式

redis提供了复制（replication）功能，可以当一台数据库的数据更新之后，自动将更新的数据同步其它数据库上。

引入主从复制机制的目的有两个：

- 一个读写分离，分担master的读写压力
- 方便做容灾恢复

##### Sentinel（哨兵）模式

哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行的多个redis实例。

在主从复制模式下增加哨兵进程，在master宕机的情况下重新从剩下的slave选举。

##### Cluster集群模式

支撑N个redis master node，每个master node都可以挂载多个slave node。

读写分离结构，对于每个master来说，写就写到master，然后读就从master对应的slave去读。

高可用，因为每个master都有slave节点，如果master挂掉，redis cluster这套机制，就会自动将某个slave切换成master。

自动将数据分片，每个master上放一部分数据。

### 集合

数组的缺点是一旦声明之后，长度就不可变。

#### List,Set,Map三者的区别

- List：存储的元素是有序的，可重复的
- Set: 存储的元素是唯一的
- Map: 使用键值对存储，key-value形式

#### List

- ArrayList：Object[]数组
- LinkedList：双向链表

#### Set

- HashSet（无序，唯一）：基于HashMap实现，底层用HashMap来保存元素
- LinkedHashSet：LinkedHashSet是HastSet的子类，并且其内部是通过LinkedHashMap实现。
- TreeSet（有序，唯一）：红黑树（自平衡的排序二叉树）

#### Map

- HashMap：Jdk8之前数组+链表组成，之后是数组+链表+红黑树
- LinkedHashMap: 在hashmap的结构之上增加了一条双向链表，使得上面的结构可以保持键值对插入的顺序
- HashTable：数组+链表组成
- TreeMap：红黑树

### hashmap

#### 介绍

HashMap基于哈希表实现的，而哈希表随着数据的增加一定会有哈希冲突（鸽巢原理），解决哈希冲突的方式有两种：

1、开发地址法：产生哈希冲突时，重新探测一个新的空闲位置，将其插入，适用于数据量较小的的情况

2、拉链法：产生哈希冲突时，在冲突位置建立链表，并将其插入链表

HashMap采用拉链法解决哈希冲突，他的数据结构是数组+链表（JDK1.8之后采用数组+链表+红黑树）

#### JDK8之后

当链表的长度大于阈值（默认8）时，会调用 **treeifyBin ()**方法。这个方法会根据HashMap数组决定是否转换成为红黑树。只有当数组长度大于或者等于64情况下，才会执行转换红黑树的操作，以减少搜索时间。否则只是调用**resize()**方法对数组进行扩容。

### 并发

**并发**：同一时间段，多个任务都在执行

**并行**：单位时间内，多个任务同时执行

#### runnable和callable区别

callable可以返回一个值或者抛出一个异常。

#### 使用多线程可能会带来哪些问题

并发编程的目的是为了提高程序执行效率和程序执行速度，但是并发编程并不总能提高程序运行速度的，而且并发可能会遇到很多问题，比如：内存泄漏，死锁和线程不安全。

#### 线程的生命周期

1、新建状态：当程序是用new关键字创建了一个线程之后，该线程处于新建状态

2、就绪状态：当线程对象调用了**start()**方法之后，该线程处于就绪状态。

3、运行状态：处于就绪状态的线程获得了CPU，则该线程处于运行状态。

4、阻塞状态：当处于运行状态的线程失去占用资源之后，便进入阻塞状态。

5、死亡状态：线程执行完毕之后，进入死亡状态

#### 死锁

多个线程同时被阻塞，它们中的一个或全部都在等待某个资源的释放。由于线程被无限期的阻塞，因此程序不可能正常终止。

#### 什么是上下文切换

任务从保存到再加载的过程就是一次上下文切换。

#### volatile

保证变量的可见性，每次使用它都到主存中进行读取。

#### ThreadLocal

实现本地线程都有自己专属本地变量

### 线程池

主要为了减少每次获取资源的消耗，提高对资源的利用率。

#### 好处

- 降低资源的消耗
- 提高响应速度
- 提高线程的可管理性

#### 执行execute()方法和submit()方法的区别是什么

- execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行完成
- submit()方法用于提交需要返回值的任务，线程池会返回一个future对象，通过这个对象可以判断任务是否执行完成

#### 如何创建线程池

##### 通过构造方法实现，类ThreadPoolExecutor

##### 通过executor框架的工具类实现

- FixedThreadPool ：固定数量的线程池
 - SingleThreadExecutor：只有一个线程的线程池
 - CachedThreadPool：该方法可以返回一个可根据实际情况调整线程数量的线程池

#### CountDownLatch 

允许count个线程阻塞在同一个地方，直至所有的任务都执行完毕















