### mysql

####  mysql引擎

mysql常见存储引擎，InnoDb,MyISAM,MEMORY。区别在事务支持，外键支持，存储限制，空间使用，插入速度的区别。

| 特性     | InnoDb | MyISAM         | MEMORY         |
| -------- | ------ | -------------- | -------------- |
| 事务支持 | 支持   | 不支持         | 不支持         |
| 外键     | 支持   | 不支持         | 不支持         |
| 存储限制 | 64TB   | 有，视情况而定 | 有，视情况而定 |
| 空间使用 | 高     | 低             | 低             |
| 内存使用 | 高     | 低             | 高             |
| 插入速度 | 低     | 高             | 高             |

mysql 5.5.5之前是默认引擎是MyISAM。

MyISAM特点：插入速度快，空间和内存使用较低。主要用于插入新纪录和读取数据。

MEMORY特点：所有数据都在内存中，数据的处理速度特别快，但是安全性不高，不能建立太大的表。

### mysql事务

一般来说，事务必须满足四个条件：原子性，一致性，隔离性，持久性

#### 原子性

一个事务中的所有操作，要么全部完成，要么全部不完成。不会结束在中间某个环节，事务在执行过程中发生错误，会被回滚至事务最开始的状态，就好像这个事务没有发生过一样。

#### 一致性

在事务的开始之前和结束之后，数据库的完整性没有被破坏。

#### 隔离性

数据库允许多个事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据库不一致。事务有不同的隔离级别：**读未提交**，**读已提交**，**可重复读**和**串行化**。mysql innodb默认隔离级别为**可重复读**。

##### 事务并发问题

- 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据。

- 不可重复读：事务A多次读取同一事务，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致。

- 幻读：系统管理员A将数据库中的学生成绩从具体分数改为ABCDE等级，但是这时系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。

  **注**：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。

#### 持久性

事务处理结束后，对数据的修改是永久的。

| 隔离级别 | **脏读** | **不可重复读** | **幻读** |
| -------- | -------- | -------------- | -------- |
| 读未提交 | 可能     | 可能           | 可能     |
| 读已提交 | 不可能   | 可能           | 可能     |
| 可重复读 | 不可能   | 不可能         | 可能     |
| 可串行化 | 不可能   | 不可能         | 不可能   |

#### mysql sql语句优化



### redis

#### 数据结构

1、string：单key，单vale。redis最基本的数据类型，一个redis字符最大支持512m

2、hash：一个键值集合

3、list：链表

4、set：集合

5、zset：有序集合

#### 常用指令

| 命令                    | 操作                                                       |
| ----------------------- | ---------------------------------------------------------- |
| keys pattern            | 以正则表达式的形式，返回匹配所有key                        |
| exists key              | 测试指定key是否存在                                        |
| type key                | 返回给定key的类型                                          |
| ttl key                 | 查看key的剩余时间                                          |
| set key value           | 设置key对应值为string的value                               |
| lpush key value1        | 在key对应的list头部（左端）添加元素                        |
| lpop key                | 移除并返回key对应的list的头部（左端）元素                  |
| sadd key value1         | 将元素添加至集合，并返回添加成功个数                       |
| srem key value1         | 从集合移除元素，返回移除成功的个数                         |
| zadd key score1 member1 | 将带有分值的成员添加到有序集合中。注意分值在前，成员在后。 |
| zrem key                | 从有序集合中删除指定成员，并返回成功删除的元素个数         |
| hset key field value    | 向散列key添加一个键值对                                    |
| hget key field          | 向散列key获取一个键的key                                   |
| hdel key field1         | 删除散列一个键值对，返回成功删除键值对的数量               |

#### 持久化

1、redis提供了两种持久化方式，分别是RDB（redis database）和AOF（Append Only File）

2、RDB（默认）：在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上。

3、AOF：将redis执行过的所有指令记录下来，下次redis重新启动时，只要这些指令重复执行一遍，就可以实现数据恢复了。

4、RDB和AOF两种方式可以同时使用。redis重启时会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。

5、如果没有数据持久化需求，也可以关闭RDB和AOF方式，这样redis将变成一个纯内存数据库。

#### redis集群三种模式

##### 主从复制模式

redis提供了复制（replication）功能，可以当一台数据库的数据更新之后，自动将更新的数据同步其它数据库上。

引入主从复制机制的目的有两个：

- 一个读写分离，分担master的读写压力
- 方便做容灾恢复

##### Sentinel（哨兵）模式

哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行的多个redis实例。

![https://segmentfault.com/img/remote/1460000022808580]()

在主从复制模式下增加哨兵进程，在master宕机的情况下重新从剩下的slave选举。

##### Cluster集群模式







